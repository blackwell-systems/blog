-# Part II: Building with JSON

**Applying architectural lessons to production systems**

Understanding why JSON succeeded doesn't build production systems. Part I established the architectural foundations--modularity, ecosystem patterns, trade-offs between integration and separation. Part II applies these lessons to concrete engineering challenges.

The following five chapters shift from theory to practice. Chapter 10 explores when JSON's strictness becomes a liability--configuration files where comments and trailing commas matter--and how human-friendly variants like JSON5 and HJSON solve it. Chapter 11 applies the modularity lessons to API design, showing how to compose JSON Schema, binary formats, and protocol choices into coherent systems. Chapter 12 examines JSON's role in modern data pipelines, from streaming architectures to batch processing. Chapter 13 covers testing strategies for JSON-heavy systems, acknowledging that flexible schemas create testing challenges. Chapter 14 evaluates JSON's future as architectural thinking continues evolving.

**These aren't separate topics--they're applications of Part I's insights.** API design decisions reflect modularity trade-offs. Configuration format choices embody the discoverability paradox. Pipeline architectures demonstrate independent evolution. Testing strategies acknowledge the validation gap. Future predictions depend on understanding architectural zeitgeist.

**Part II makes the architectural lessons concrete:** From understanding JSON's ecosystem to building systems that leverage it effectively. From knowing why patterns survive to applying those patterns in production. From theory to practice.

The foundation is built. Now we build systems.
