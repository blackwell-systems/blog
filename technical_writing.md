# Technical Writing Career Guide

Personal reference for pursuing technical writing opportunities while maintaining backend engineering career.

## Table of Contents

- [Current Position (Dec 2025)](#current-position-dec-2025)
- [When You Can Call Yourself a Technical Writer](#when-you-can-call-yourself-a-technical-writer)
- [Dual Employment Strategy](#dual-employment-strategy)
- [LinkedIn Positioning](#linkedin-positioning)
- [Resume Positioning](#resume-positioning)
- [Job Titles & Roles](#job-titles--roles)
  - [Roles You're Qualified For Now](#roles-youre-qualified-for-now)
  - [Roles That Require More Experience](#roles-that-require-more-experience-6-12-months-away)
- [Job Search Strategy](#job-search-strategy)
- [What to Avoid vs. Pursue](#what-to-avoid-vs-pursue)
- [Salary Expectations (US, 2025)](#salary-expectations-us-2025)
- [Why Your Background is Valuable](#why-your-background-is-valuable)
- [Building Your Portfolio](#building-your-portfolio)
  - [Published Articles](#published-articles-27-total)
  - [Open Source Projects](#open-source-projects-10-production-tools)
    - [1. blackdot](#1-blackdot)
    - [2. dotclaude](#2-dotclaude)
    - [3. error-envelope (Rust)](#3-error-envelope-rust)
    - [4. err-envelope (Go)](#4-err-envelope-go)
    - [5. vaultmux](#5-vaultmux)
    - [6. pipeboard](#6-pipeboard)
    - [7. gcp-secret-manager-emulator](#7-gcp-secret-manager-emulator)
    - [8. mdfx](#8-mdfx)
    - [9. domainstack](#9-domainstack)
    - [10. prettychars](#10-prettychars)
- [Interview Preparation](#interview-preparation)
- [Next Steps](#next-steps)
- [Resources](#resources)
- [Final Assessment](#final-assessment)

---

## Current Position (Dec 2025)

**Background:**
- 4 years backend engineering in enterprise hospitality
- Created API and system documentation for technical and non-technical stakeholders
- Extensive experience writing integration documentation relied upon by external partners
- Founder, Blackwell Systems (OSS + future proprietary developer tools)
- 10 open-source projects with comprehensive documentation
- Published technical blog: 94,152 lines of markdown content
- Total documentation: ~190,000 lines across all projects
- 3x AWS Certified, Azure, Terraform

**Strategy:** Dual employment - maintain backend engineering while pursuing technical writing contracts/opportunities.

**Qualification Status:** Qualified for Senior/Staff technical writing roles based on portfolio.

---

## When You Can Call Yourself a Technical Writer

You're qualified when you have:
- ✓ Regular technical content production
- ✓ Readers finding value in your work
- ✓ A body of work to show (portfolio/blog)

**All three criteria met.**

### What Makes You Credible

1. **You write about what you build** - Not copying tutorials, but deep dives into systems you understand
2. **Your writing is structured** - TOCs, headers, examples, tables - scannable reference material
3. **You have a specialty** - Shell automation, developer tools, error handling, documentation patterns
4. **You maintain consistency** - Regular posts, series structure, sustained output

---

## Dual Employment Strategy

**Goal:** Maintain backend engineering career while pursuing technical writing contracts/opportunities.

**Approach:** Position existing OSS and writing work as separate business (Blackwell Systems), pursue contracts without conflict with primary employment.

---

## LinkedIn Positioning

### Headline Options

**Recommended:**
```
Founder & Engineer, Blackwell Systems | Backend Engineering | Technical Writing | 3x AWS + Azure + Terraform Certified
```

**Alternative:**
```
Senior Backend Engineer | Founder, Blackwell Systems | Technical Writer | 190k+ Lines Documentation | 3x AWS Certified
```

**Why "Founder" positioning:**
- Explains 10 major projects (it's your company, not hobby)
- Sets up future proprietary products
- Works for both engineering and writing audiences
- Shows entrepreneurial initiative

### Experience Section

**Entry 1: Blackwell Systems (Your Company)**
```
Founder & Engineer
Blackwell Systems | Self-Employed
2021 - Present

Building developer tools and infrastructure software that eliminate repetitive work 
and improve developer experience across platforms.

Technical Work:
• Built unified secrets management supporting 8+ backends (vaultmux) - write once, deploy anywhere
• Created standardized error handling for Rust and Go APIs with trace IDs and retry hints
• Developed cross-platform environment replication system (blackdot) - one command setup
• Built full-stack validation framework (domainstack) - define once, validate everywhere (API + frontend)
• Created local GCP Secret Manager emulator for testing without cloud credentials
• Developed encrypted SSH clipboard sync (pipeboard) for seamless remote workflows
• Built profile management for Claude Code (dotclaude) with context auto-detection
• Created offline README enhancement tool (mdfx) generating SVG badges locally
• Developed zero-overhead Unicode text styling library (prettychars) for CLI tools

Documentation & Technical Writing:
• Authored comprehensive documentation for all projects (~96,000 lines)
• Built 6 interactive documentation sites using docs-as-code practices
• Published technical blog covering shell automation, glob patterns, and system design (94,152 lines)
• Wrote API references, architecture guides, CLI documentation, and developer onboarding
• Total documentation portfolio: ~190,000 lines

Portfolio: blackwell-systems.github.io/blog/ | github.com/blackwell-systems
```

**Entry 2: Current Backend Role**
```
Backend Engineer
[Current Company]
2020 - Present

[Your backend engineering work - standard description]
[Keep this separate, don't mention documentation overlap]
```

**What each audience sees:**
- **Backend employers:** "They have a side company, that's cool" (not threatening)
- **Writing contracts:** "They run a developer tools company" (credible, substantial)
- **Neither knows about the other** - OSS work is legitimately independent

---

## Resume Positioning

### Resume 1: Backend Engineering Focus

**For backend/cloud engineering roles:**

```
Software Engineer & Technical Writer
Blackwell Systems | 2021 - Present

- Published 27 technical articles (94,152 lines) covering shell automation, 
  glob patterns, error handling, and documentation best practices
- Created "Mastering ZSH" series (4 parts) covering hooks, completions, 
  prompts, and custom widgets
- Wrote "Glob Patterns" series explaining invisible abstractions in developer tooling
- Maintained comprehensive documentation for 10 open-source projects (86,000+ lines)
- Built 6 interactive documentation sites using docs-as-code practices

Portfolio: blackwell-systems.github.io/blog/ | github.com/blackwell-systems
```

### Backend Engineer with Documentation Experience

```
Senior Backend Engineer & Technical Writer
[Company] | 2020-Present

Backend Engineering:
- Designed and maintained microservices architecture for hospitality platform
- Built APIs for booking, payments, and property management system integrations

Technical Documentation:
- Authored API and system documentation for both technical and non-technical stakeholders
- Created integration documentation relied upon by external partners for system integrations
- Documented microservices architecture, API contracts, and integration patterns
- Published external technical blog covering developer tools and system architecture

Portfolio: blackwell-systems.github.io/blog/
```

### Interview Positioning

"I'm a backend engineer with 4 years of experience writing API and integration documentation for both technical and non-technical audiences in enterprise hospitality. I've created documentation relied upon by external partners for system integrations, combining deep technical understanding with the ability to explain complex systems clearly. Beyond my enterprise work, I've published 27 technical articles and maintain comprehensive documentation for 10 open-source projects totaling 190,000 lines. My writing focuses on making complex technical concepts accessible - from API contracts and integration patterns to developer tools and system architecture."

---

## Job Titles & Roles

### Roles You're Qualified For Now

#### 1. Developer Advocate / Developer Relations
**What it is:**
- Writing technical content for external developers
- Creating tutorials, guides, sample applications
- Engaging with developer community
- Speaking at conferences/meetups (optional)

**Companies:** Stripe, Vercel, PlanetScale, Temporal, HashiCorp, Cloudflare

**Salary:** $120-180k (US, major tech hubs)

**Why you're qualified:**
- Your blog IS the portfolio
- You write about tools you actually use and build
- You have engineering credibility

#### 2. Technical Content Creator
**What it is:**
- Writing tutorials and guides for developer-facing products
- SEO-optimized technical articles
- Code examples, sample projects
- Video content (sometimes)

**Companies:** Startups, open-source projects, dev tool companies

**Salary:** $80-140k (varies widely)

**Why you're qualified:**
- You're literally doing this already
- 27 published articles with code examples
- SEO-optimized comprehensive guides

#### 3. Documentation Engineer
**What it is:**
- Writing docs for developer-facing products
- Docs-as-code: Docusaurus, OpenAPI specs, automated docs
- Infrastructure: CI/CD for docs, versioning, search
- 50% writing, 50% engineering

**Companies:** Meta, Google, Netflix, Airbnb, Stripe, DataDog

**Salary:** $140-200k (high because it's engineering + writing)

**Why you're qualified:**
- Backend engineering experience (4 years)
- Your blog shows writing ability (27 articles, 94k lines)
- 10 OSS projects with complete documentation (86k lines)
- API documentation (error-envelope), CLI docs (dotfiles, mdfx), emulator docs (gcp-secret-manager)

#### 4. Technical Writer (Developer Tools Focus)
**What it is:**
- Writing documentation for CLIs, APIs, SDKs
- Developer-facing, not end-user manuals
- API reference, integration guides, tutorials
- Working closely with engineering teams

**Companies:** CLI tool companies, API platforms, infrastructure companies

**Salary:** $100-150k

**Why you're qualified:**
- Your README article shows you understand user-facing documentation
- 10 OSS projects with complete documentation ecosystems
- error-envelope: API documentation, err-envelope: Go error patterns
- dotfiles, dotclaude, mdfx: CLI tool documentation
- Backend experience means you understand the systems

#### 5. Senior Technical Writer - Developer Experience
**What it is:**
- Write for internal developer platforms
- Improve onboarding docs, service templates, best practices
- Audience: internal engineers at the company
- Document Kubernetes platforms, CI/CD, observability

**Companies:** Uber, Lyft, DoorDash, Airbnb, Netflix

**Salary:** $130-180k

**Why you're qualified:**
- 4 years creating API and system documentation for enterprise hospitality
- Experience writing for both technical and non-technical stakeholders
- Created integration documentation relied upon by external partners
- Deep understanding of microservices, distributed systems, and API contracts
- You know what confuses developers because you've documented complex systems

#### 6. API Technical Writer
**What it is:**
- Document REST APIs, GraphQL, webhooks
- Write for external integration partners
- OpenAPI/Swagger specs, SDKs, code examples
- Focus on developer-facing API products

**Companies:** Stripe, Twilio, SendGrid, PayPal, Brex, Plaid

**Salary:** $100-150k (junior), $150-200k (senior)

**Why you're qualified:**
- Backend engineering: you've built these systems
- You understand API design, contracts, error handling
- error-envelope shows API documentation ability

#### 7. Staff Technical Writer - Platform Team
**What it is:**
- Document internal platforms for engineers
- Kubernetes, CI/CD, service mesh, observability
- High-level role: influence platform design for documentation
- Work with staff engineers on architecture decisions

**Companies:** Large tech companies (FAANG+, unicorns)

**Salary:** $140-200k

**Why you're qualified:**
- 4 years backend engineering
- You've built on these platforms
- You know what platform teams need documented
- Engineering credibility to influence design

### Roles That Require More Experience (6-12 Months Away)

#### API Technical Writer (Stripe/Twilio Level)
**Gap:** Need 2-3 years focused documentation experience

**How to get there:**
- Contribute to open-source API documentation
- Write more API-focused blog posts
- Document your own APIs in detail
- 6-12 months focused effort

#### Senior Technical Writer
**Gap:** Need docs tooling experience (Docusaurus, docs-as-code, CI/CD)

**How to get there:**
- Set up docs-as-code for your blog or projects
- Learn Docusaurus, Mintlify, or similar
- Add search, versioning, CI/CD to docs
- 1-2 years focused effort

#### Documentation Team Lead
**Gap:** Need management experience + docs experience

**How to get there:**
- 3-5 years in docs roles first
- Then move to lead/management

---

## Job Search Strategy

### Where to Look

**Job Boards:**
- LinkedIn: "Technical Writer" + "Developer" or "API" or "Platform"
- Indeed: Filter by "Developer Tools" companies
- AngelList/Wellfound: Startups need docs, often pay equity
- Write the Docs job board: https://www.writethedocs.org/jobs/
- DevRel Careers: https://devrelcareers.com/

**Companies to Target:**

**Developer Tools:**
- Vercel, Railway, Render, Fly.io (platform-as-service)
- PlanetScale, Neon, Supabase (database)
- Temporal, Inngest (workflow engines)
- Prisma, Drizzle (ORMs)

**Infrastructure:**
- HashiCorp, Pulumi, Terraform
- DataDog, New Relic, Honeycomb (observability)
- Cloudflare, Fastly (edge/CDN)

**APIs & SDKs:**
- Stripe, Twilio, SendGrid
- PayPal, Brex, Plaid (fintech)
- Algolia, Meilisearch (search)

**Open Source:**
- Many open-source projects hire docs maintainers
- $50-100k for part-time or contract work
- Check Open Collective, GitHub Sponsors

**Enterprise (Your Advantage):**
- Hospitality tech: Amadeus, Sabre, IDeaS (adjacent to your experience)
- Platform teams at: Uber, Lyft, DoorDash, Airbnb
- Internal developer experience teams at FAANG

### How to Apply

**1. Add Technical Writer to Resume/LinkedIn Today**
- You've earned it
- Link to your blog
- Highlight documentation work

**2. Apply to "Technical Writer" Roles in Dev Tools Space**
- Filter for: CLI tools, APIs, developer platforms, internal platforms
- Avoid: Enterprise business software (CRM, ERP user manuals)
- Avoid: End-user documentation (unless you want it)

**3. Direct Outreach**
- Find companies you like with poor docs
- "I write about developer tools. Here's my blog. Do you need documentation help?"
- Many startups need docs but don't have an open req
- Twitter/LinkedIn DMs to DevRel/docs teams

**4. Open Source Contributions**
- Find a project you use with poor docs
- Submit documentation PRs
- Builds portfolio, gets noticed
- Can lead to paid docs work

**5. Contract/Freelance First**
- Easier to get contract docs work
- Builds portfolio
- Can convert to full-time
- Upwork, Toptal, specialized docs agencies

---

## What to Avoid vs. Pursue

### Pursue: Developer-Facing Documentation

**Good:**
- API documentation (REST, GraphQL)
- CLI tool documentation
- SDK/library documentation
- Internal platform documentation (Kubernetes, CI/CD)
- Developer onboarding guides
- Architecture decision records (ADRs)
- Runbooks and operational docs
- Integration guides for engineers

**Characteristics:**
- Audience: Software engineers
- Content: Code examples, API specs, architecture
- Style: Technical, precise, assumes programming knowledge

### Avoid: End-User Business Documentation (Unless You Like It)

**Skip:**
- End-user manuals ("Click the Submit button")
- Business process documentation ("How to file a TPS report")
- Compliance/regulatory documentation
- Non-technical user guides
- Enterprise software user manuals (SAP, Oracle, etc.)

**Characteristics:**
- Audience: Business users, non-technical staff
- Content: Screenshots, step-by-step UI instructions
- Style: Simple, assumes no technical knowledge

**Exception:** If you find this interesting, do it. But based on your blog content, you're more suited to developer-facing docs.

---

## Salary Expectations (US, 2025)

### By Experience Level

**Entry-Level Technical Writer (0-2 years):**
- $60-90k (general)
- $80-110k (developer tools focus)

**Mid-Level Technical Writer (2-5 years):**
- $90-130k (general)
- $110-150k (developer tools/API focus)

**Senior Technical Writer (5-8 years):**
- $120-160k (general)
- $140-180k (developer tools/internal platforms)

**Staff Technical Writer (8+ years):**
- $150-200k (FAANG/large tech)
- Often includes equity

**Documentation Engineer (hybrid role):**
- $140-200k (because it's engineering + writing)
- Higher than pure technical writing

**Developer Advocate/DevRel:**
- $120-180k (varies widely)
- Equity common at startups

### Your Starting Range

**With 4 years backend engineering + published blog:**
- Target: Senior Technical Writer ($130-160k)
- Or: Documentation Engineer ($140-180k)
- Or: Developer Advocate ($120-160k)

**Don't apply for entry-level roles.** You have 4 years experience.

### Geographic Adjustments

**San Francisco / NYC / Seattle:**
- +20-30% above base numbers
- $140-200k for senior roles

**Remote (US company):**
- Usually SF-adjusted or slightly below
- $120-180k for senior roles

**Remote (non-US company hiring US):**
- Varies widely
- Often 10-20% below US market

**Non-US markets:**
- Europe: €60-100k (£50-85k UK)
- Canada: CAD 90-140k
- Australia: AUD 110-160k

---

## Why Your Background is Valuable

### Enterprise Backend Engineering + Writing = Rare Combination

**Most technical writers:**
- Come from journalism/English backgrounds
- Learned tech on the job
- Struggle with complex systems (microservices, distributed systems)
- Need engineers to explain everything

**You:**
- Built backend systems for 4 years
- Understand microservices, APIs, databases, messaging
- Can read code and understand architecture
- Don't need things explained - you've built them

**This means:**
- You can write docs faster (no learning curve)
- You catch technical errors engineers miss
- You have instant credibility with engineering teams
- You can influence API design for better documentation

### Hospitality Domain Experience

**Advantage for:**
- Travel tech companies (Booking.com, Expedia, Airbnb)
- Hospitality platforms (Amadeus, Sabre, IDeaS, Duetto)
- Payment platforms (hospitality-focused)
- Point-of-sale systems (Toast, Square, Lightspeed)

You understand:
- Booking flows, availability, inventory
- PCI compliance, payments, chargebacks
- Integrations with property management systems
- Real-time pricing, revenue management

**This domain knowledge + technical writing = very valuable niche.**

---

## Building Your Portfolio

### What You Already Have

**Published Articles (27 total):**
- Mastering ZSH series (4 parts: hooks, completion system, prompts, widgets)
- Glob patterns series (2 parts: invisible abstraction, complete syntax reference)
- README as landing page (documentation sprawl and extraction patterns)
- Error handling guides (error-envelope patterns, Rust error handling)
- Shell scripting, developer tools, and system architecture
- All articles: comprehensive (1,500-5,000+ words), with code examples and diagrams

**Open Source Projects (10 Production Tools):**

### 1. blackdot
**GitHub:** https://github.com/blackwell-systems/blackdot

**Problem:** Maintaining consistent development environments across multiple machines and platforms is a nightmare of manual syncing, platform-specific quirks, and configuration drift.

**Solution:** blackdot is a modular dotfiles framework that reimagines environment management for the era of AI-assisted coding and multi-platform workflows. Unlike traditional dotfiles relying on symlinks and shell scripts, blackdot implements a **feature registry architecture** where developers activate only needed components through an interactive wizard or granular presets (minimal, developer, Claude, full).

**5-Layer Configuration System:**
1. **Environment** (`BLACKDOT_*` vars): Session-only overrides for testing/CI
2. **Project** (`.blackdot.json`): Git-tracked project-specific settings (auto-venv, hooks, aliases)
3. **Machine** (`~/.config/blackdot/machine.json`): This-computer-only (vault backend, workspace path, work vs personal)
4. **User** (`~/.config/blackdot/config.json`): Default preferences across all machines
5. **Defaults**: Built-in fallbacks

Each layer overrides lower priority layers, enabling work laptop using 1Password while personal desktop uses Bitwarden—same codebase, different machine configs. Handlebars templating enables sophisticated variable interpolation and conditional logic across platform-specific configurations.

**Technical Architecture:**
- **vaultmux integration**: Unified secrets API abstracting over Bitwarden, 1Password, and pass with automatic vault discovery and drift detection
- **19 lifecycle hooks**: Pre-commit hooks prevent secret leaks, post-sync hooks rebuild completions, workspace-change hooks activate environments
- **Workspace portability**: `/workspace` symlink (configurable target like `~/code`) maintains session portability—Claude Code sessions using `/workspace/project` paths work identically across macOS/Linux/WSL2 regardless of underlying OS conventions

**Built for Claude Code:**
- Portable AI coding sessions with project-specific profiles
- Git safety hooks preventing destructive operations
- Cross-machine synchronization for consistent AI assistance everywhere

**Developer Tool Integrations (120+ aliases):**
- **AWS Tools** (`aws_helpers`): Profile switching with fzf, SSO login/logout, identity display, role assumption
- **CDK Tools** (`cdk_tools`): Deploy, diff, synth with smart defaults and environment awareness
- **Rust Tools** (`rust_tools`): Build, test, clippy, fmt, cargo-watch integration
- **Go Tools** (`go_tools`): Build, test with coverage, module management, tool installation
- **Python Tools** (`python_tools`): uv package manager, pytest integration, auto-venv activation
- **Docker Tools** (`docker_tools`): Container lifecycle, compose management, network utilities
- **SSH Tools** (`ssh_tools`): Config management, key handling, agent setup, tunnel automation
- **NVM** (`nvm_integration`): Lazy-loaded Node.js version manager
- **SDKMAN** (`sdkman_integration`): Lazy-loaded Java/Gradle/Kotlin manager

**Self-Healing Architecture:** Continuous monitoring of configuration drift, missing dependencies, and secrets availability with automatic repair—transforming static dotfiles into an intelligent, self-maintaining development environment orchestration system that provides comprehensive toolchain integration across 9 developer ecosystems.

### 2. dotclaude
**GitHub:** https://github.com/blackwell-systems/dotclaude

**Problem:** Working across multiple projects with different coding standards, tech stacks, and compliance requirements means constantly switching Claude Code contexts manually—or worse, using the wrong standards for the current project and getting inappropriate AI guidance.

**Solution:** dotclaude implements a **layered profile management system** built specifically for Claude Code configuration. A universal "base" configuration provides foundational standards (git workflows, security practices, tool usage) while project-specific "profiles" overlay contextual details without duplication. One-command switching between work environments via automatic `.dotclaude` file detection.

**Technical Architecture:**
- **Layered inheritance model**: Base configuration + profile overrides eliminate content duplication
- **Automatic context detection**: `.dotclaude` files in project root trigger instant profile activation
- **Sophisticated merging algorithm**: Prevents configuration conflicts while maintaining clear precedence rules (project > profile > base)
- **Cross-platform support**: Native Go binaries for Linux, macOS, Windows
- **Version-controlled synchronization**: Profiles sync via Git for consistent AI guidance across machines

**Workflow Automation:**
- **Git hook system**: Automatic profile activation on branch switching or repository changes
- **Preview mode**: Test configuration changes before applying to catch errors
- **Automatic versioning**: Configuration backups prevent accidental data loss
- **Session management**: Tracks active profile and provides status visibility

**Configuration Management:**
- Merges without duplicating shared settings
- Project-specific overrides (TypeScript standards, API conventions, testing frameworks, linting rules)
- Tech stack awareness (React vs Vue, REST vs GraphQL, monorepo vs multi-repo)
- Compliance requirements (enterprise security policies, code review standards)

**Real-World Usage:**
- Switch between client projects with different coding standards
- Maintain personal preferences while adapting to team conventions
- Handle compliance variations across enterprise/OSS work
- Seamless transitions between work contexts without manual reconfiguration

**Value:** Transforms Claude Code from a static AI assistant into a context-aware development partner that automatically adapts guidance to specific project requirements, preventing inappropriate suggestions and maintaining consistency across team members.

### 3. error-envelope (Rust)
**GitHub:** https://github.com/blackwell-systems/error-envelope

**Problem:** Rust web APIs need three layers of error handling—domain logic (thiserror), application propagation (anyhow), and HTTP responses—but nothing bridges anyhow to structured HTTP contracts. Every endpoint reinvents JSON error formatting, trace IDs, and retry logic.

**Solution:** error-envelope completes the Rust error handling ecosystem as the **HTTP boundary layer**. Sits between anyhow (propagation) and web frameworks (Axum), implementing a predictable JSON envelope with 18 type-safe HTTP error codes that automatically convert from anyhow::Error while preserving semantic meaning.

**The Rust Error Handling Stack:**
- **thiserror** (domain layer): Typed errors for business logic with pattern matching (`PaymentError::InsufficientFunds`)
- **anyhow** (application layer): Ergonomic error propagation with `?` operator and context chaining
- **error-envelope** (HTTP boundary): Converts both into consistent HTTP responses with status codes, trace IDs, retry hints
- **Axum** (framework): IntoResponse implementation for seamless integration

**Technical Architecture:**
- **Framework-agnostic core**: ~500 lines, zero dependencies, works standalone
- **Optional integrations**: `anyhow-support` (From<anyhow::Error>), `axum-support` (IntoResponse) via Cargo features
- **Type-safe error codes**: Enum prevents invalid HTTP status/code combinations at compile time
- **Automatic HTTP semantics**: 404 for NotFound, 429 for RateLimited with Retry-After header, 400 for ValidationFailed with field details
- **Trace ID propagation**: Attaches trace IDs, emits X-Request-ID headers for distributed tracing

**Key Features:**
- **Structured validation errors**: Field-level validation with HashMap<String, String> details
- **Retry hints**: Duration-based retry_after with automatic Retry-After header generation
- **Builder pattern**: Fluent API for adding trace IDs, details, metadata
- **thiserror mapping**: Implement `From<DomainError>` for error-envelope to map domain errors to HTTP semantics

**Ecosystem Integration:**
```rust
// Domain errors (thiserror) → Application propagation (anyhow) → HTTP boundary (error-envelope) → Framework (Axum)
async fn handler() -> Result<Json<User>, Error> {
    let user = db::find_user(&id).await?;  // anyhow error converts automatically
    Ok(Json(user))
}
```

**Value:** Completes the Rust error handling story by providing the missing HTTP layer. Eliminates per-endpoint error formatting while maintaining type safety from domain logic to HTTP responses. Published on crates.io with comprehensive docs showing integration patterns across the entire error handling stack.

### 4. err-envelope (Go)
**GitHub:** https://github.com/blackwell-systems/err-envelope

**Problem:** Standard Go error handling results in inconsistent JSON responses and poor observability across microservices—every service invents its own error format.

**Solution:** err-envelope provides a **standardized error envelope** with predefined fields (code, message, details, trace_id, retryable status) accessible through a single `Write()` method handling status codes, headers, and JSON encoding automatically.

**Technical Architecture:**
- **Trace middleware**: Generates request IDs, propagates X-Request-Id headers, adds trace context for downstream services
- **Structured logging integration**: `slog.LogValuer` implementation automatically includes error metadata in logs
- **Performance optimized**: Minimal dependencies (stdlib only), ~300 lines, zero-allocation error construction
- **JSON schema definitions**: For contract testing and client tooling

**Key Features:**
- Single `Write()` method for consistent error responses
- Enhanced observability through automatic trace propagation
- Cross-service consistency in polyglot architectures
- Maintains Go's explicit error handling philosophy

**Value:** Transforms Go's simple error interface into a rich, traceable system without sacrificing performance or idiomaticity.

### 5. vaultmux
**GitHub:** https://github.com/blackwell-systems/vaultmux

**Problem:** Teams use different secret providers (Bitwarden, 1Password, AWS, GCP, Azure, pass) requiring provider-specific code in every application—vendor lock-in, painful migrations, and duplicate secret management logic across services.

**Solution:** vaultmux implements a **unified Backend interface** abstracting 7+ secret management systems behind consistent Go method signatures. Write your secret management code once, users choose their preferred backend without you changing application code.

**Supported Backends:**
- **CLI-based**: Bitwarden (bw), 1Password (op), pass (GPG), Windows Credential Manager (PowerShell)
- **SDK-based**: AWS Secrets Manager, Google Cloud Secret Manager, Azure Key Vault
- **Testing**: Comprehensive mock backend with 98%+ core test coverage

**Technical Architecture:**
- **Factory pattern**: Functional configuration options enabling "write once, run anywhere" code
- **Zero core dependencies**: Clean abstractions without bloat
- **Context support**: All operations support Go context for cancellation and timeouts
- **Type-safe interfaces**: Explicit method signatures prevent runtime surprises
- **No global state**: Explicit session management without singletons

**Authentication Mechanisms:**
- **CLI backends**: Shell out to respective CLIs (interactive and non-interactive modes)
- **SDK backends**: Native authentication (AWS IAM, GCP ADC, Azure CLI)
- **Session caching**: Configurable TTL (default 30min), automatic token refresh
- **Backend auto-detection**: Discovers available backends automatically

**Configuration Flexibility:**
- Backend-specific options (AWS regions, GCP project IDs, path prefixes)
- Configurable session TTL per backend
- Support for multiple authentication scenarios (local dev, CI/CD, production)

**Error Handling Philosophy:** "Fail fast, fail clearly"—comprehensive error handling preserves backend-specific context (rate limits, auth failures) while providing consistent error types for application logic.

**Integration Points:**
- **Local development**: Mock backend for deterministic testing without credentials
- **CI/CD pipelines**: Flexible backend selection without code changes
- **Production services**: Session pooling and automatic retry with backoff

**Value:** Eliminates vendor lock-in, enables customer choice of secret provider, prevents secret management code duplication, and supports testing without production credentials—transforming fragmented provider-specific implementations into a unified, testable abstraction.

### 6. pipeboard
**GitHub:** https://github.com/blackwell-systems/pipeboard

**Problem:** Traditional clipboard managers treat clipboards as ephemeral, single-device state—useless for developers working across multiple machines who need persistent, synchronized, programmable clipboard workflows.

**Solution:** pipeboard reimagines clipboard management as a **programmable, networked data pipeline** for terminal-centric developers. Implements persistent named slots with searchable history and bidirectional real-time synchronization across devices.

**Technical Architecture:**
- **Three backend modes**: Local storage (offline), S3 buckets (team sharing), hosted backends (mobile sync)
- **Security**: Client-side AES-256-GCM encryption with configurable time-based auto-expiry—secrets self-destruct after TTL
- **Synchronization**: SSH peer-to-peer clipboard transfers eliminating cloud dependencies while maintaining end-to-end encryption
- **Cross-platform**: macOS, Linux (Wayland/X11), Windows, WSL via unified CLI abstracting platform-specific tools

**Transformation Pipeline:**
- Pipe clipboard through jq for JSON formatting
- Strip ANSI codes before sharing
- Base64 encode secrets
- Chain custom transformations—all in real-time without manual copy-paste

**Watch Mode:** Bidirectional sync where clipboard changes on any device instantly propagate to all connected machines, creating a distributed clipboard mesh that feels like a single shared clipboard.

**Architectural Sophistication:** Zero-telemetry design (all data on your machines), slot management treating clipboard history as queryable state, and programmable workflows. Built in Go (92.2%) with modular separation of clipboard management, authentication, encryption, and synchronization—systems thinking applied to a tool most never considered programmable.

### 7. gcp-secret-manager-emulator
**GitHub:** https://github.com/blackwell-systems/gcp-secret-manager-emulator

**Problem:** Testing GCP Secret Manager code requires cloud connectivity, authentication, and expensive resources—slowing down local development and CI/CD pipelines.

**Solution:** A complete **Secret Manager v1 API-compatible gRPC emulator** supporting core operations (secret creation, version management, access control) that runs locally in milliseconds without GCP credentials.

**Technical Architecture:**
- **gRPC implementation**: Full API compatibility with official `cloud.google.com/go/secretmanager` client
- **In-memory storage**: Thread-safe concurrent access enabling deterministic testing
- **Zero code changes**: Test and production use identical client code, just point at localhost
- **Rapid startup**: Millisecond initialization supporting tight development loops

**Deployment Options:**
- Standalone binary execution
- Docker containers
- Programmatic embedding with configurable ports/logging

**Production-Ready Testing:**
- High test coverage
- Minimal dependencies preventing version conflicts
- Intentionally omits advanced features (IAM) not needed for testing

**Value:** Transforms GCP Secret Manager development from cloud-dependent (auth + network) into fast, reliable local experience enabling offline work, reduced CI/CD costs, and consistent testing environments.

### 8. mdfx
**GitHub:** https://github.com/blackwell-systems/mdfx

**Problem:** External README enhancement services (shields.io) have limited customization, require network access, and break documentation builds when they go down.

**Solution:** A comprehensive **Rust library for local SVG generation** creating rich, customizable components (progress bars, gauges, sparklines, tech badges) entirely offline with zero external dependencies.

**Technical Architecture:**
- **Local SVG rendering**: Complex visual elements external services can't create
- **24 Unicode text styles**: Without requiring additional fonts
- **Simple Icons integration**: Brand-colored tech badges with extensive customization (corners, borders, theming, chevron variations)
- **500+ named Unicode symbols**: For inline text enhancement
- **Offline-first pipeline**: Prevents external service failures from breaking builds

**Integration Points:**
- GitHub README rendering
- Local documentation generation
- CI/CD pipelines with restricted network access

**Key Advantages:**
- Never breaks: no external APIs, renders at commit time
- Granular customization control
- Consistent visual components across environments

**Value:** Transforms README creation from external service dependence into a powerful, flexible toolset with zero-dependency reliability.

### 9. domainstack
**GitHub:** https://github.com/blackwell-systems/domainstack

**Problem:** Business rules duplicated across frontend TypeScript, backend validation, and API docs lead to drift, bugs, and massive maintenance overhead.

**Solution:** domainstack implements **"valid-by-construction domain objects"** through Rust's type system with a two-stage validation approach: Serde handles shape/type, Domain validation enforces semantic business rules. Define once, validate everywhere.

**Technical Architecture:**
- **Derive macro system**: `#[derive(Validate)]` with 37+ built-in rules (strings, numerics, collections)
- **Code generation**: Auto-produces TypeScript/Zod schemas, JSON Schema (Draft 2020-12), OpenAPI specs from Rust rules
- **WASM compilation**: Identical validation logic runs in browsers—same error structures and business rules across server/client
- **Framework adapters**: Axum, Actix-web, Rocket with one-line extraction
- **Async validation support**: For database uniqueness checks

**Key Features:**
- Complex nested and cross-field validation with precise error path tracking
- Single-source-of-truth consistency
- Type-state approach: invalid states difficult/impossible to represent at compile time
- Zero-dependency core design

**Value:** Eliminates validation duplication across the stack while maintaining compile-time guarantees and precise user feedback.

### 10. prettychars
**GitHub:** https://github.com/blackwell-systems/prettychars

**Problem:** Terminal applications need Unicode glyphs, but runtime string matching creates latency bottlenecks and inconsistent rendering frustrates UIs.

**Solution:** prettychars leverages **Perfect Hash Functions (PHF)** achieving O(1) lookup for 531 named glyphs with compile-time hash map generation—eliminating runtime computation entirely.

**Technical Architecture:**
- **Compile-time optimization**: Perfect hash functions generate static data, zero runtime allocation
- **Glyph catalog**: 531 glyphs across 18 categories (arrows, box drawing, shapes, math symbols, currency)
- **24 text styling transformations**: For enhanced terminal output
- **Automatic variation selector (VS15) application**: Ensures consistent rendering across terminals
- **Append-only name registry**: Prevents breaking changes across versions

**Performance:**
- ~2ns per glyph lookup (O(1))
- ~15ns per character styling
- 8KB binary overhead
- Zero-cost abstractions

**Usage:** Intuitive named access like `glyph("arrow.right")` → `→`

**Architectural Sophistication:** Compile-time code generation transforms Unicode access from runtime string operations into direct memory lookups while ensuring terminal rendering consistency.

**Value:** Transforms terminal UI development from manual Unicode hunting into declarative glyph usage maintaining high performance and consistent presentation.

**What These Projects Demonstrate:**
- **Systems-level thinking**: Each tool addresses developer friction at different layers (environment, configuration, errors, secrets, validation)
- **Abstraction design**: vaultmux, error-envelope, and domainstack eliminate repetitive code through elegant interfaces
- **Performance engineering**: prettychars and domainstack show compile-time optimization and zero-cost abstractions
- **Security-first approach**: pipeboard encryption, vaultmux secrets management, zero-telemetry designs
- **Developer experience**: Local-first tools (utf8fx, gcp-emulator), cross-platform consistency (dotfiles, dotclaude)
- **Production readiness**: Trace IDs, structured logging, comprehensive error handling, testing infrastructure

**Documentation Volume:**
- Blog: 94,152 lines (verified)
- OSS projects: ~96,000 lines (9 verified at 86,011 + pipeboard estimated ~10k)
- Total: ~190,000 lines

**This is Staff-level documentation volume.**

### What to Add (Optional)

**1. API Documentation Sample**
- Pick a public API with poor docs
- Rewrite a section as sample
- Shows API docs ability

**2. Tutorial Sample**
- "Build X with Y" style guide
- Step-by-step, code examples
- Shows tutorial writing

**3. Conceptual Documentation Sample**
- "How X Works Under the Hood" (like your glob article)
- Architecture explanation
- Shows ability to explain complex systems

**4. Reference Documentation Sample**
- Complete API reference
- Shows attention to detail, completeness

**You already have all four types in your blog.** No additional samples needed unless applying to a specific role that asks for something different.

---

## Interview Preparation

### Common Questions

**"Why do you want to move from engineering to technical writing?"**

Good answer:
- "I've realized I get more satisfaction from teaching and explaining systems than building them. My blog has 27 articles because I genuinely enjoy breaking down complex topics. I want to do that full-time."
- Or: "I want a hybrid role where I can leverage my engineering experience to create better documentation. I've seen how bad docs slow down developers, and I want to fix that."

Bad answer:
- "I'm tired of coding" (sounds burnt out)
- "Writing is easier than engineering" (not true, sounds lazy)

**"What's your experience with [docs tool]?"**

If you don't know the tool:
- "I haven't used [tool] specifically, but I'm familiar with docs-as-code workflows. I can get up to speed quickly."
- "I've used [similar tool], and the concepts are transferable."

If you do know it:
- Show examples from your blog/projects

**"How do you handle working with difficult engineers?"**

Good answer:
- "I've been an engineer for 4 years, so I understand the perspective. Engineers resist docs when they're not given time or when docs feel like busywork. I focus on making docs easy - I draft them, they review. I ask specific questions instead of 'can you document this?'"

**"How do you prioritize what to document?"**

Good answer:
- "I start with what users ask about most - support tickets, GitHub issues, Slack questions. High-impact, high-confusion areas first. Then foundational concepts. Polish comes last."

**"Show me your writing process."**

Walk through one of your blog articles:
1. Pick a topic based on pain point (glob patterns - everyone uses, nobody learns)
2. Research (check existing docs, test examples)
3. Outline structure (TOC first)
4. Write sections with examples
5. Test all code examples
6. Edit for clarity
7. Get feedback (if applicable)
8. Publish

### Technical Tests

**Many companies give writing tests:**
- "Document this API" (give you OpenAPI spec)
- "Write a tutorial for X"
- "Explain this technical concept"

**Your advantage:** You can actually test the code and understand the system. Most writers copy-paste from engineering specs. You can verify, improve, and catch errors.

**Preparation:**
- Practice writing a quick API reference (30 minutes)
- Practice writing a tutorial (1 hour)
- Practice explaining a complex system (your blog already does this)

---

## Next Steps

### Immediate (This Week)

1. **Update LinkedIn:**
   - Add "Technical Writer" to headline
   - Add blog link to featured section
   - Update experience to highlight documentation work

2. **Update Resume:**
   - Add documentation experience from enterprise role
   - Add blog/portfolio section
   - Quantify where possible ("reduced onboarding time 40%")

3. **Set Up Job Alerts:**
   - LinkedIn: "Technical Writer" + "Developer" or "API"
   - Indeed: "Documentation Engineer", "Developer Advocate"
   - Write the Docs job board

### Short Term (This Month)

4. **Apply to 5-10 Roles:**
   - Mix of: DevRel, Documentation Engineer, Technical Writer
   - Focus on developer tools companies
   - Use the positioning statements above

5. **Direct Outreach:**
   - Find 5 companies with poor docs
   - Send cold emails/DMs
   - "I write about developer tools, noticed your docs could improve"

6. **Open Source Contribution:**
   - Pick one project with poor docs
   - Submit a docs PR
   - Builds portfolio, shows initiative

### Long Term (Next 3-6 Months)

7. **Write More:**
   - Continue blog series
   - More articles = stronger portfolio
   - Focus on pain points in your domain

8. **Learn Docs Tooling (Optional):**
   - Set up Docusaurus for a project
   - Learn OpenAPI spec generation
   - Adds "Documentation Engineer" qualification

9. **Network:**
   - Write the Docs community
   - DevRel community on Twitter
   - Comment on technical writing discussions

---


## Resources

### Communities

- **Write the Docs:** https://www.writethedocs.org/
  - Slack: Very active, welcoming
  - Conferences: Portland, Prague, Australia
  - Job board

- **DevRel Collective:** https://devrelcollective.fun/
  - Slack community
  - Resources for Developer Relations

- **API the Docs:** https://apithedocs.org/
  - Focused on API documentation
  - Conferences and community


### Tools to Learn (Optional)

**Docs Platforms:**
- Docusaurus (React-based)
- Mintlify (AI-powered)
- GitBook
- ReadTheDocs

**API Documentation:**
- OpenAPI/Swagger
- Postman
- Redoc
- Stoplight

**Diagrams:**
- Mermaid (you already use this)
- Excalidraw
- Lucidchart

---

## Final Assessment

**You are qualified to call yourself a technical writer today.**

**You can apply for technical writing roles today.**

**Target roles: Senior Technical Writer, Documentation Engineer, Developer Advocate.**

**Salary expectation: $120-180k (US, major tech hubs).**

**Your unique advantage: Engineering experience + writing ability + domain expertise.**

**Next step: Update resume/LinkedIn, apply to 5 roles this week.**

---

*Document created: December 27, 2025*
*Last updated: December 27, 2025*
