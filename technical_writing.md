# Technical Writing Career Guide

Personal reference for pursuing technical writing opportunities while maintaining backend engineering career.

## Current Position (Dec 2025)

**Background:**
- 4 years backend engineering in enterprise hospitality
- Founder, Blackwell Systems (OSS + future proprietary developer tools)
- 10 open-source projects with comprehensive documentation
- Published technical blog: 94,152 lines of markdown content
- Total documentation: ~190,000 lines across all projects
- 3x AWS Certified, Azure, Terraform

**Strategy:** Dual employment - maintain backend engineering while pursuing technical writing contracts/opportunities.

**Qualification Status:** Qualified for Senior/Staff technical writing roles based on portfolio.

---

## When You Can Call Yourself a Technical Writer

You're qualified when you have:
- ✓ Regular technical content production
- ✓ Readers finding value in your work
- ✓ A body of work to show (portfolio/blog)

**All three criteria met.**

### What Makes You Credible

1. **You write about what you build** - Not copying tutorials, but deep dives into systems you understand
2. **Your writing is structured** - TOCs, headers, examples, tables - scannable reference material
3. **You have a specialty** - Shell automation, developer tools, error handling, documentation patterns
4. **You maintain consistency** - Regular posts, series structure, sustained output

---

## Dual Employment Strategy

**Goal:** Maintain backend engineering career while pursuing technical writing contracts/opportunities.

**Approach:** Position existing OSS and writing work as separate business (Blackwell Systems), pursue contracts without conflict with primary employment.

---

## LinkedIn Positioning

### Headline Options

**Recommended:**
```
Founder & Engineer, Blackwell Systems | Backend Engineering | Technical Writing | 3x AWS + Azure + Terraform Certified
```

**Alternative:**
```
Senior Backend Engineer | Founder, Blackwell Systems | Technical Writer | 190k+ Lines Documentation | 3x AWS Certified
```

**Why "Founder" positioning:**
- Explains 10 major projects (it's your company, not hobby)
- Sets up future proprietary products
- Works for both engineering and writing audiences
- Shows entrepreneurial initiative

### Experience Section

**Entry 1: Blackwell Systems (Your Company)**
```
Founder & Engineer
Blackwell Systems | Self-Employed
2021 - Present

Building developer tools and infrastructure software that eliminate repetitive work 
and improve developer experience across platforms.

Technical Work:
• Built unified secrets management supporting 8+ backends (vaultmux) - write once, deploy anywhere
• Created standardized error handling for Rust and Go APIs with trace IDs and retry hints
• Developed cross-platform environment replication system (dotfiles) - one command setup
• Built full-stack validation framework (domainstack) - define once, validate everywhere (API + frontend)
• Created local GCP Secret Manager emulator for testing without cloud credentials
• Developed encrypted SSH clipboard sync (pipeboard) for seamless remote workflows
• Built profile management for Claude Code (dotclaude) with context auto-detection
• Created offline README enhancement tool (utf8fx) generating SVG badges locally
• Developed zero-overhead Unicode text styling library (prettychars) for CLI tools

Documentation & Technical Writing:
• Authored comprehensive documentation for all projects (~96,000 lines)
• Built 6 interactive documentation sites using docs-as-code practices
• Published technical blog covering shell automation, glob patterns, and system design (94,152 lines)
• Wrote API references, architecture guides, CLI documentation, and developer onboarding
• Total documentation portfolio: ~190,000 lines

Portfolio: blackwell-systems.github.io/blog/ | github.com/blackwell-systems
```

**Entry 2: Current Backend Role**
```
Backend Engineer
[Current Company]
2020 - Present

[Your backend engineering work - standard description]
[Keep this separate, don't mention documentation overlap]
```

**What each audience sees:**
- **Backend employers:** "They have a side company, that's cool" (not threatening)
- **Writing contracts:** "They run a developer tools company" (credible, substantial)
- **Neither knows about the other** - OSS work is legitimately independent

---

## Resume Positioning

### Resume 1: Backend Engineering Focus

**For backend/cloud engineering roles:**

```
Software Engineer & Technical Writer
Blackwell Systems | 2021 - Present

- Published 27 technical articles (94,152 lines) covering shell automation, 
  glob patterns, error handling, and documentation best practices
- Created "Mastering ZSH" series (4 parts) covering hooks, completions, 
  prompts, and custom widgets
- Wrote "Glob Patterns" series explaining invisible abstractions in developer tooling
- Maintained comprehensive documentation for 10 open-source projects (86,000+ lines)
- Built 6 interactive documentation sites using docs-as-code practices

Portfolio: blackwell-systems.github.io/blog/ | github.com/blackwell-systems
```

### Backend Engineer with Documentation Experience

```
Senior Backend Engineer & Technical Writer
[Company] | 2020-Present

Backend Engineering:
- Designed and maintained microservices architecture for hospitality platform
- [Existing backend experience]

Technical Documentation:
- Authored internal API documentation for booking, payments, and integration services
- Created developer onboarding guides reducing ramp-up time by 40%
- Maintained architecture decision records (ADRs) for platform decisions
- Published external technical blog covering developer tools and system design

Portfolio: blackwell-systems.github.io/blog/
```

### Interview Positioning

"I'm a software engineer who specializes in developer tools and writes extensively about the systems I build. I've published 27 technical articles on shell automation, glob patterns, ZSH, and system architecture, and I maintain comprehensive documentation for 10 open-source projects. My writing focuses on explaining invisible infrastructure - things developers use daily but never learn formally, like glob patterns and ZSH completions."

---

## Job Titles & Roles

### Roles You're Qualified For Now

#### 1. Developer Advocate / Developer Relations
**What it is:**
- Writing technical content for external developers
- Creating tutorials, guides, sample applications
- Engaging with developer community
- Speaking at conferences/meetups (optional)

**Companies:** Stripe, Vercel, PlanetScale, Temporal, HashiCorp, Cloudflare

**Salary:** $120-180k (US, major tech hubs)

**Why you're qualified:**
- Your blog IS the portfolio
- You write about tools you actually use and build
- You have engineering credibility

#### 2. Technical Content Creator
**What it is:**
- Writing tutorials and guides for developer-facing products
- SEO-optimized technical articles
- Code examples, sample projects
- Video content (sometimes)

**Companies:** Startups, open-source projects, dev tool companies

**Salary:** $80-140k (varies widely)

**Why you're qualified:**
- You're literally doing this already
- 27 published articles with code examples
- SEO-optimized comprehensive guides

#### 3. Documentation Engineer
**What it is:**
- Writing docs for developer-facing products
- Docs-as-code: Docusaurus, OpenAPI specs, automated docs
- Infrastructure: CI/CD for docs, versioning, search
- 50% writing, 50% engineering

**Companies:** Meta, Google, Netflix, Airbnb, Stripe, DataDog

**Salary:** $140-200k (high because it's engineering + writing)

**Why you're qualified:**
- Backend engineering experience (4 years)
- Your blog shows writing ability (27 articles, 94k lines)
- 10 OSS projects with complete documentation (86k lines)
- API documentation (error-envelope), CLI docs (dotfiles, utf8fx), emulator docs (gcp-secret-manager)

#### 4. Technical Writer (Developer Tools Focus)
**What it is:**
- Writing documentation for CLIs, APIs, SDKs
- Developer-facing, not end-user manuals
- API reference, integration guides, tutorials
- Working closely with engineering teams

**Companies:** CLI tool companies, API platforms, infrastructure companies

**Salary:** $100-150k

**Why you're qualified:**
- Your README article shows you understand user-facing documentation
- 10 OSS projects with complete documentation ecosystems
- error-envelope: API documentation, err-envelope: Go error patterns
- dotfiles, dotclaude, utf8fx: CLI tool documentation
- Backend experience means you understand the systems

#### 5. Senior Technical Writer - Developer Experience
**What it is:**
- Write for internal developer platforms
- Improve onboarding docs, service templates, best practices
- Audience: internal engineers at the company
- Document Kubernetes platforms, CI/CD, observability

**Companies:** Uber, Lyft, DoorDash, Airbnb, Netflix

**Salary:** $130-180k

**Why you're qualified:**
- 4 years backend engineering in enterprise
- You know what confuses new backend engineers
- You've read bad internal docs and know what's missing
- Understanding of microservices, distributed systems

#### 6. API Technical Writer
**What it is:**
- Document REST APIs, GraphQL, webhooks
- Write for external integration partners
- OpenAPI/Swagger specs, SDKs, code examples
- Focus on developer-facing API products

**Companies:** Stripe, Twilio, SendGrid, PayPal, Brex, Plaid

**Salary:** $100-150k (junior), $150-200k (senior)

**Why you're qualified:**
- Backend engineering: you've built these systems
- You understand API design, contracts, error handling
- error-envelope shows API documentation ability

#### 7. Staff Technical Writer - Platform Team
**What it is:**
- Document internal platforms for engineers
- Kubernetes, CI/CD, service mesh, observability
- High-level role: influence platform design for documentation
- Work with staff engineers on architecture decisions

**Companies:** Large tech companies (FAANG+, unicorns)

**Salary:** $140-200k

**Why you're qualified:**
- 4 years backend engineering
- You've built on these platforms
- You know what platform teams need documented
- Engineering credibility to influence design

### Roles That Require More Experience (6-12 Months Away)

#### API Technical Writer (Stripe/Twilio Level)
**Gap:** Need 2-3 years focused documentation experience

**How to get there:**
- Contribute to open-source API documentation
- Write more API-focused blog posts
- Document your own APIs in detail
- 6-12 months focused effort

#### Senior Technical Writer
**Gap:** Need docs tooling experience (Docusaurus, docs-as-code, CI/CD)

**How to get there:**
- Set up docs-as-code for your blog or projects
- Learn Docusaurus, Mintlify, or similar
- Add search, versioning, CI/CD to docs
- 1-2 years focused effort

#### Documentation Team Lead
**Gap:** Need management experience + docs experience

**How to get there:**
- 3-5 years in docs roles first
- Then move to lead/management

---

## Job Search Strategy

### Where to Look

**Job Boards:**
- LinkedIn: "Technical Writer" + "Developer" or "API" or "Platform"
- Indeed: Filter by "Developer Tools" companies
- AngelList/Wellfound: Startups need docs, often pay equity
- Write the Docs job board: https://www.writethedocs.org/jobs/
- DevRel Careers: https://devrelcareers.com/

**Companies to Target:**

**Developer Tools:**
- Vercel, Railway, Render, Fly.io (platform-as-service)
- PlanetScale, Neon, Supabase (database)
- Temporal, Inngest (workflow engines)
- Prisma, Drizzle (ORMs)

**Infrastructure:**
- HashiCorp, Pulumi, Terraform
- DataDog, New Relic, Honeycomb (observability)
- Cloudflare, Fastly (edge/CDN)

**APIs & SDKs:**
- Stripe, Twilio, SendGrid
- PayPal, Brex, Plaid (fintech)
- Algolia, Meilisearch (search)

**Open Source:**
- Many open-source projects hire docs maintainers
- $50-100k for part-time or contract work
- Check Open Collective, GitHub Sponsors

**Enterprise (Your Advantage):**
- Hospitality tech: Amadeus, Sabre, IDeaS (adjacent to your experience)
- Platform teams at: Uber, Lyft, DoorDash, Airbnb
- Internal developer experience teams at FAANG

### How to Apply

**1. Add Technical Writer to Resume/LinkedIn Today**
- You've earned it
- Link to your blog
- Highlight documentation work

**2. Apply to "Technical Writer" Roles in Dev Tools Space**
- Filter for: CLI tools, APIs, developer platforms, internal platforms
- Avoid: Enterprise business software (CRM, ERP user manuals)
- Avoid: End-user documentation (unless you want it)

**3. Direct Outreach**
- Find companies you like with poor docs
- "I write about developer tools. Here's my blog. Do you need documentation help?"
- Many startups need docs but don't have an open req
- Twitter/LinkedIn DMs to DevRel/docs teams

**4. Open Source Contributions**
- Find a project you use with poor docs
- Submit documentation PRs
- Builds portfolio, gets noticed
- Can lead to paid docs work

**5. Contract/Freelance First**
- Easier to get contract docs work
- Builds portfolio
- Can convert to full-time
- Upwork, Toptal, specialized docs agencies

---

## What to Avoid vs. Pursue

### Pursue: Developer-Facing Documentation

**Good:**
- API documentation (REST, GraphQL)
- CLI tool documentation
- SDK/library documentation
- Internal platform documentation (Kubernetes, CI/CD)
- Developer onboarding guides
- Architecture decision records (ADRs)
- Runbooks and operational docs
- Integration guides for engineers

**Characteristics:**
- Audience: Software engineers
- Content: Code examples, API specs, architecture
- Style: Technical, precise, assumes programming knowledge

### Avoid: End-User Business Documentation (Unless You Like It)

**Skip:**
- End-user manuals ("Click the Submit button")
- Business process documentation ("How to file a TPS report")
- Compliance/regulatory documentation
- Non-technical user guides
- Enterprise software user manuals (SAP, Oracle, etc.)

**Characteristics:**
- Audience: Business users, non-technical staff
- Content: Screenshots, step-by-step UI instructions
- Style: Simple, assumes no technical knowledge

**Exception:** If you find this interesting, do it. But based on your blog content, you're more suited to developer-facing docs.

---

## Salary Expectations (US, 2025)

### By Experience Level

**Entry-Level Technical Writer (0-2 years):**
- $60-90k (general)
- $80-110k (developer tools focus)

**Mid-Level Technical Writer (2-5 years):**
- $90-130k (general)
- $110-150k (developer tools/API focus)

**Senior Technical Writer (5-8 years):**
- $120-160k (general)
- $140-180k (developer tools/internal platforms)

**Staff Technical Writer (8+ years):**
- $150-200k (FAANG/large tech)
- Often includes equity

**Documentation Engineer (hybrid role):**
- $140-200k (because it's engineering + writing)
- Higher than pure technical writing

**Developer Advocate/DevRel:**
- $120-180k (varies widely)
- Equity common at startups

### Your Starting Range

**With 4 years backend engineering + published blog:**
- Target: Senior Technical Writer ($130-160k)
- Or: Documentation Engineer ($140-180k)
- Or: Developer Advocate ($120-160k)

**Don't apply for entry-level roles.** You have 4 years experience.

### Geographic Adjustments

**San Francisco / NYC / Seattle:**
- +20-30% above base numbers
- $140-200k for senior roles

**Remote (US company):**
- Usually SF-adjusted or slightly below
- $120-180k for senior roles

**Remote (non-US company hiring US):**
- Varies widely
- Often 10-20% below US market

**Non-US markets:**
- Europe: €60-100k (£50-85k UK)
- Canada: CAD 90-140k
- Australia: AUD 110-160k

---

## Why Your Background is Valuable

### Enterprise Backend Engineering + Writing = Rare Combination

**Most technical writers:**
- Come from journalism/English backgrounds
- Learned tech on the job
- Struggle with complex systems (microservices, distributed systems)
- Need engineers to explain everything

**You:**
- Built backend systems for 4 years
- Understand microservices, APIs, databases, messaging
- Can read code and understand architecture
- Don't need things explained - you've built them

**This means:**
- You can write docs faster (no learning curve)
- You catch technical errors engineers miss
- You have instant credibility with engineering teams
- You can influence API design for better documentation

### Hospitality Domain Experience

**Advantage for:**
- Travel tech companies (Booking.com, Expedia, Airbnb)
- Hospitality platforms (Amadeus, Sabre, IDeaS, Duetto)
- Payment platforms (hospitality-focused)
- Point-of-sale systems (Toast, Square, Lightspeed)

You understand:
- Booking flows, availability, inventory
- PCI compliance, payments, chargebacks
- Integrations with property management systems
- Real-time pricing, revenue management

**This domain knowledge + technical writing = very valuable niche.**

---

## Building Your Portfolio

### What You Already Have

**Published Articles (27 total):**
- Mastering ZSH series (4 parts: hooks, completion system, prompts, widgets)
- Glob patterns series (2 parts: invisible abstraction, complete syntax reference)
- README as landing page (documentation sprawl and extraction patterns)
- Error handling guides (error-envelope patterns, Rust error handling)
- Shell scripting, developer tools, and system architecture
- All articles: comprehensive (1,500-5,000+ words), with code examples and diagrams

**Open Source Projects (10 Production Tools):**

### 1. dotfiles
Blackwell Systems' dotfiles framework tackles the universal developer frustration of maintaining consistent development environments across multiple machines and platforms. Rather than traditional static configuration files, it implements a sophisticated CLI-driven system with `blackdot` commands that provide interactive setup wizards, feature toggles, and automated health checks. The architecture centers on a unified secrets API that abstracts over Bitwarden, 1Password, and pass, enabling automatic vault discovery and drift detection across machines. The framework's modular design uses a 5-layer configuration hierarchy with Handlebars templating, allowing developers to start minimal and incrementally add features through granular presets. Cross-platform compatibility spans macOS, Linux, Windows, and WSL2, maintaining session portability through consistent `/workspace` symlinks. What makes this technically sophisticated is its 19 lifecycle hooks system, Claude Code integration for portable AI coding sessions, and self-healing "doctor" functionality that automatically detects and repairs configuration drift. The system transforms dotfiles from static configuration into a dynamic, adaptive development environment that evolves with developer needs.

### 2. dotclaude
dotclaude solves the configuration management nightmare that plagues developers working across multiple projects with different coding standards, tech stacks, and compliance requirements. The system implements a layered inheritance model where a universal "base" configuration provides foundational standards (git workflows, security practices, tool usage), while project-specific "profiles" overlay contextual details without duplication. The technical architecture uses `.dotclaude` files for automatic context detection, enabling seamless one-command switching between different work environments. The profile system merges configurations intelligently, allowing developers to maintain consistent practices while adapting to project-specific requirements like TypeScript standards, API conventions, or testing frameworks. Integration points include Git workflow automation through hooks, session management with preview modes, and cross-machine synchronization via version control. What makes this implementation notable is its sophisticated merging algorithm that prevents configuration conflicts while maintaining precedence rules, the automated hook system that triggers contextual workflows, and the ability to test configuration changes in preview mode before applying them. This transforms Claude Code from a static AI assistant into a context-aware development partner that adapts its guidance to specific project requirements.

### 3. error-envelope (Rust)
The error-envelope crate addresses Rust web services' inconsistent error handling, where different endpoints return varying error structures that frustrate API consumers and complicate monitoring. The library implements a type-safe enum with 18 standardized HTTP error codes, providing constructors for common scenarios while maintaining a predictable JSON envelope structure across all error types. The technical approach uses Rust's trait system elegantly, implementing `From<anyhow::Error>` for seamless error conversion and `IntoResponse` for Axum integration, while keeping the core framework-agnostic. Key capabilities include automatic trace ID attachment for distributed tracing, retry hints with backoff strategies, and structured metadata that enables sophisticated error analysis. The architecture supports optional features through Cargo flags (anyhow-support, axum-support), maintaining a minimal core while enabling rich integrations. What makes this implementation technically sophisticated is its type-state approach to error construction, compile-time guarantees about error structure consistency, and the way it transforms ad-hoc error handling into a systematic approach. The library establishes a "predictable contract" where every error response has the same structure and fields, enabling clients to handle errors consistently and operations teams to build reliable monitoring around standardized error patterns.

### 4. err-envelope (Go)
The err-envelope package revolutionizes Go's traditionally fragmented error handling by providing a structured, traceable error response system that maintains consistency across services. Unlike standard Go error handling that often results in inconsistent JSON responses and poor observability, this package implements a standardized error envelope with predefined fields (code, message, details, trace_id, retryable status) accessible through a single `Write()` method that handles status codes, headers, and JSON encoding automatically. The technical architecture includes trace middleware that generates request IDs, propagates X-Request-Id headers, and adds trace context for downstream services. The package integrates deeply with Go's structured logging through `slog.LogValuer` implementation, automatically including error metadata in log outputs for enhanced observability. Performance optimization is achieved through minimal dependencies (standard library only), approximately 300 lines of code, and zero-allocation error construction patterns. What makes this implementation technically notable is how it transforms Go's simple error interface into a rich, traceable system without sacrificing performance or idiomaticity. The package includes JSON schema definitions for contract testing and client tooling, enabling consistent error handling across polyglot service architectures while maintaining Go's philosophy of explicit error handling.

### 5. vaultmux
vaultmux tackles the operational complexity of managing secrets across heterogeneous infrastructure where teams use different secret providers (Bitwarden, 1Password, AWS Secrets Manager, etc.) but need unified programmatic access. The library implements a sophisticated Backend interface that abstracts CLI-based tools (Bitwarden, 1Password, pass) and SDK-based services (AWS, GCP, Azure) behind consistent method signatures for authentication, retrieval, and synchronization. The technical architecture uses a factory pattern with functional configuration options, enabling "write once, run anywhere" secret management code that prevents vendor lock-in. Session management includes configurable TTL caching (default 30 minutes), automatic token refresh, and explicit state management without global variables. Integration points span local development (mock backends for testing), CI/CD pipelines (multiple provider support), and production services (session pooling). What makes this design technically sophisticated is its "fail fast, fail clearly" philosophy combined with comprehensive error handling that preserves backend-specific error context while providing consistent error types. The architecture diagram illustrates how different authentication mechanisms (CLI prompts, SDK tokens, file-based keys) converge through a unified interface, enabling developers to switch secret providers without changing application code. This transforms secret management from a fragmented, provider-specific process into a clean abstraction that supports testing, development velocity, and operational flexibility.

### 6. pipeboard
pipeboard addresses the productivity friction of managing clipboard data across multiple machines, platforms, and contexts where traditional clipboard managers fail to provide secure, programmable, cross-device synchronization. The technical implementation uses SSH for peer-to-peer clipboard transfers, eliminating cloud dependencies while maintaining security through direct machine-to-machine encrypted connections. The architecture employs AES-256-GCM client-side encryption with configurable backends (local, S3, hosted) and supports time-based auto-expiry for sensitive data that self-destructs. The slot management system provides persistent, named storage with searchable history that survives reboots and network changes, while the transformation pipeline enables user-defined processing (JSON formatting, ANSI stripping) that operates on clipboard data in real-time. Cross-platform compatibility spans macOS, Linux, Windows, and WSL through unified terminal interfaces, with mobile synchronization via hosted backends. What makes this implementation technically sophisticated is its bidirectional real-time sync capabilities, zero-telemetry privacy approach, and programmable clipboard routing that treats clipboard data as a first-class development tool. The system transforms clipboard management from a simple cut-and-paste operation into a secure, distributed data pipeline that enhances developer workflows across devices and environments while maintaining strong security guarantees through end-to-end encryption.

### 7. gcp-secret-manager-emulator
The GCP Secret Manager emulator solves the integration testing bottleneck where developers need to test Secret Manager interactions without GCP connectivity, expensive cloud resources, or complex authentication setup during local development and CI/CD pipelines. The technical implementation provides complete Secret Manager v1 API compatibility through gRPC, supporting core operations (secret creation, version management, access control) while intentionally omitting advanced features like IAM methods that aren't needed for testing scenarios. The architecture uses in-memory storage with thread-safe concurrent access, enabling deterministic testing without persistence overhead or encryption complexity that would slow down test execution. The emulator integrates seamlessly with the official `cloud.google.com/go/secretmanager` client library, requiring zero code changes between test and production environments. Deployment flexibility includes standalone binary execution, Docker containers, and programmatic embedding with configurable ports and logging levels. What makes this implementation production-ready for testing is its high test coverage, minimal dependencies that prevent version conflicts, and rapid startup times that support tight development loops. The system transforms GCP Secret Manager development from a cloud-dependent process requiring authentication and network connectivity into a fast, reliable local development experience that enables offline work, reduces CI/CD costs, and provides consistent testing environments across development teams.

### 8. utf8fx
utf8fx addresses the limitations of existing README enhancement tools like shields.io by providing a comprehensive Rust library for generating rich, customizable SVG components entirely offline with zero external dependencies. The technical approach centers on local SVG generation that renders complex visual elements (progress bars, gauges, sparklines, charts) that external services cannot create, while supporting 24 Unicode text styles without requiring additional fonts. The architecture includes a sophisticated badge system using Simple Icons for brand-colored tech badges with extensive customization options (corner control, borders, theming, chevron variations) and a 500+ named Unicode symbol library for inline text enhancement. The rendering pipeline operates completely offline, preventing external service failures that break documentation builds and enabling consistent visual components across different deployment environments. Integration points include GitHub README rendering, local documentation generation, and CI/CD pipelines where network access may be restricted. What makes this implementation technically distinctive is its comprehensive approach to visual documentation enhancement combined with reliability guarantees through local-only generation. The library transforms README creation from dependence on external services with limited customization into a powerful, flexible toolset that gives developers granular control over visual presentation while maintaining zero-dependency reliability that prevents documentation breakage due to external service outages.

### 9. domainstack
domainstack tackles the validation inconsistency plague in full-stack applications where business rules are duplicated across frontend TypeScript, backend validation, and API documentation, leading to drift, bugs, and maintenance overhead. The technical architecture implements "valid-by-construction domain objects" through Rust's type system, using a two-stage validation approach: Serde handles shape/type validation while Domain validation enforces semantic business rules. The derive macro system (`#[derive(Validate)]`) enables declarative validation with 37+ built-in rules across strings, numerics, and collections, supporting complex nested and cross-field validation with precise error path tracking. The code generation strategy automatically produces TypeScript/Zod schemas, JSON Schema (Draft 2020-12), and OpenAPI specifications directly from Rust validation rules, ensuring single-source-of-truth consistency. WASM compilation support enables identical validation logic to run in browsers, providing the same error structures and business rules across server and client without duplication. Framework integration includes adapters for Axum, Actix-web, and Rocket with one-line extraction and automatic validation, while async validation support handles complex scenarios like database uniqueness checks. What makes this implementation sophisticated is its type-state validation approach that makes "invalid states difficult or impossible to represent" at compile time, combined with zero-dependency core design and comprehensive error tracking that enables precise user feedback across the entire application stack.

### 10. prettychars
prettychars solves the performance and consistency challenges of Unicode glyph lookups in terminal applications, where runtime string matching creates latency bottlenecks and inconsistent glyph rendering frustrates user interfaces. The technical implementation leverages Perfect Hash Functions (PHF) to achieve O(1) lookup times for 531 named glyphs across 18 categories, with compile-time hash map generation that eliminates runtime hash computation entirely. The glyph catalog organization spans comprehensive Unicode coverage including arrows, box drawing, shapes, mathematical symbols, and currency, while supporting 24 different text styling transformations for enhanced terminal output. Compile-time optimization strategies include automatic variation selector (VS15) application for consistent rendering, static data generation with zero runtime allocation, and append-only name registry design that prevents breaking changes across library versions. Performance characteristics demonstrate zero-cost abstractions with approximately 2ns per glyph lookup and 15ns per character styling, requiring minimal binary overhead (8KB) while supporting intuitive named access like "arrow.right". What makes this implementation technically efficient is its sophisticated compile-time code generation that transforms Unicode glyph access from runtime string operations into direct memory lookups, combined with careful attention to terminal rendering consistency through automatic variation selector handling. The library transforms terminal UI development from manual Unicode code hunting into declarative glyph usage that maintains high performance and consistent visual presentation across different terminal environments.

**What These Projects Demonstrate:**
- **Systems-level thinking**: Each tool addresses developer friction at different layers (environment, configuration, errors, secrets, validation)
- **Abstraction design**: vaultmux, error-envelope, and domainstack eliminate repetitive code through elegant interfaces
- **Performance engineering**: prettychars and domainstack show compile-time optimization and zero-cost abstractions
- **Security-first approach**: pipeboard encryption, vaultmux secrets management, zero-telemetry designs
- **Developer experience**: Local-first tools (utf8fx, gcp-emulator), cross-platform consistency (dotfiles, dotclaude)
- **Production readiness**: Trace IDs, structured logging, comprehensive error handling, testing infrastructure

**Documentation Volume:**
- Blog: 94,152 lines (verified)
- OSS projects: ~96,000 lines (9 verified at 86,011 + pipeboard estimated ~10k)
- Total: ~190,000 lines

**This is Staff-level documentation volume.**

### What to Add (Optional)

**1. API Documentation Sample**
- Pick a public API with poor docs
- Rewrite a section as sample
- Shows API docs ability

**2. Tutorial Sample**
- "Build X with Y" style guide
- Step-by-step, code examples
- Shows tutorial writing

**3. Conceptual Documentation Sample**
- "How X Works Under the Hood" (like your glob article)
- Architecture explanation
- Shows ability to explain complex systems

**4. Reference Documentation Sample**
- Complete API reference
- Shows attention to detail, completeness

**You already have all four types in your blog.** No additional samples needed unless applying to a specific role that asks for something different.

---

## Interview Preparation

### Common Questions

**"Why do you want to move from engineering to technical writing?"**

Good answer:
- "I've realized I get more satisfaction from teaching and explaining systems than building them. My blog has 27 articles because I genuinely enjoy breaking down complex topics. I want to do that full-time."
- Or: "I want a hybrid role where I can leverage my engineering experience to create better documentation. I've seen how bad docs slow down developers, and I want to fix that."

Bad answer:
- "I'm tired of coding" (sounds burnt out)
- "Writing is easier than engineering" (not true, sounds lazy)

**"What's your experience with [docs tool]?"**

If you don't know the tool:
- "I haven't used [tool] specifically, but I'm familiar with docs-as-code workflows. I can get up to speed quickly."
- "I've used [similar tool], and the concepts are transferable."

If you do know it:
- Show examples from your blog/projects

**"How do you handle working with difficult engineers?"**

Good answer:
- "I've been an engineer for 4 years, so I understand the perspective. Engineers resist docs when they're not given time or when docs feel like busywork. I focus on making docs easy - I draft them, they review. I ask specific questions instead of 'can you document this?'"

**"How do you prioritize what to document?"**

Good answer:
- "I start with what users ask about most - support tickets, GitHub issues, Slack questions. High-impact, high-confusion areas first. Then foundational concepts. Polish comes last."

**"Show me your writing process."**

Walk through one of your blog articles:
1. Pick a topic based on pain point (glob patterns - everyone uses, nobody learns)
2. Research (check existing docs, test examples)
3. Outline structure (TOC first)
4. Write sections with examples
5. Test all code examples
6. Edit for clarity
7. Get feedback (if applicable)
8. Publish

### Technical Tests

**Many companies give writing tests:**
- "Document this API" (give you OpenAPI spec)
- "Write a tutorial for X"
- "Explain this technical concept"

**Your advantage:** You can actually test the code and understand the system. Most writers copy-paste from engineering specs. You can verify, improve, and catch errors.

**Preparation:**
- Practice writing a quick API reference (30 minutes)
- Practice writing a tutorial (1 hour)
- Practice explaining a complex system (your blog already does this)

---

## Next Steps

### Immediate (This Week)

1. **Update LinkedIn:**
   - Add "Technical Writer" to headline
   - Add blog link to featured section
   - Update experience to highlight documentation work

2. **Update Resume:**
   - Add documentation experience from enterprise role
   - Add blog/portfolio section
   - Quantify where possible ("reduced onboarding time 40%")

3. **Set Up Job Alerts:**
   - LinkedIn: "Technical Writer" + "Developer" or "API"
   - Indeed: "Documentation Engineer", "Developer Advocate"
   - Write the Docs job board

### Short Term (This Month)

4. **Apply to 5-10 Roles:**
   - Mix of: DevRel, Documentation Engineer, Technical Writer
   - Focus on developer tools companies
   - Use the positioning statements above

5. **Direct Outreach:**
   - Find 5 companies with poor docs
   - Send cold emails/DMs
   - "I write about developer tools, noticed your docs could improve"

6. **Open Source Contribution:**
   - Pick one project with poor docs
   - Submit a docs PR
   - Builds portfolio, shows initiative

### Long Term (Next 3-6 Months)

7. **Write More:**
   - Continue blog series
   - More articles = stronger portfolio
   - Focus on pain points in your domain

8. **Learn Docs Tooling (Optional):**
   - Set up Docusaurus for a project
   - Learn OpenAPI spec generation
   - Adds "Documentation Engineer" qualification

9. **Network:**
   - Write the Docs community
   - DevRel community on Twitter
   - Comment on technical writing discussions

---

## Decision: Full-Time Technical Writing vs. Hybrid Role

### Full-Time Technical Writing

**Pros:**
- Deep focus on documentation quality
- Clear career path (Junior → Senior → Staff → Lead)
- Less on-call, less production pressure
- Writing every day

**Cons:**
- Engineering skills may atrophy
- Can feel disconnected from product
- Lower ceiling than staff engineer ($200k vs $300k+)
- May miss hands-on coding

**Good if:** You genuinely prefer writing to coding, want work-life balance, enjoy teaching/explaining.

### Hybrid Role (Documentation Engineer / Developer Advocate)

**Pros:**
- Keep engineering skills sharp
- Build tools to support documentation
- Higher salary ceiling
- More variety in work

**Cons:**
- May not be "deep" in either writing or engineering
- Can be pulled in multiple directions
- Fewer roles available (niche)

**Good if:** You like both writing and building, want flexibility, enjoy variety.

### Stay Engineer, Write on the Side

**Pros:**
- Highest salary potential (staff engineer = $300k+)
- Keep all engineering career options open
- Blog builds personal brand
- Less risk

**Cons:**
- Writing is "extra" work, not your job
- May not have time to write consistently
- Don't get feedback/editing from team

**Good if:** You like engineering, writing is a hobby, want the blog to stay fun.

---

## Resources

### Communities

- **Write the Docs:** https://www.writethedocs.org/
  - Slack: Very active, welcoming
  - Conferences: Portland, Prague, Australia
  - Job board

- **DevRel Collective:** https://devrelcollective.fun/
  - Slack community
  - Resources for Developer Relations

- **API the Docs:** https://apithedocs.org/
  - Focused on API documentation
  - Conferences and community

### Learning Resources

**Books:**
- "Docs for Developers" by Jared Bhatti et al.
- "Every Page is Page One" by Mark Baker
- "The Product is Docs" by Splunk team

**Courses:**
- Google Technical Writing Course (free)
- Write the Docs resources
- API documentation courses (Udemy, Coursera)

**Blogs to Follow:**
- I'd Rather Be Writing (Tom Johnson)
- Write the Docs blog
- Every Page is Page One (Mark Baker)
- Divio documentation system

### Tools to Learn (Optional)

**Docs Platforms:**
- Docusaurus (React-based)
- Mintlify (AI-powered)
- GitBook
- ReadTheDocs

**API Documentation:**
- OpenAPI/Swagger
- Postman
- Redoc
- Stoplight

**Diagrams:**
- Mermaid (you already use this)
- Excalidraw
- Lucidchart

---

## Final Assessment

**You are qualified to call yourself a technical writer today.**

**You can apply for technical writing roles today.**

**Target roles: Senior Technical Writer, Documentation Engineer, Developer Advocate.**

**Salary expectation: $120-180k (US, major tech hubs).**

**Your unique advantage: Engineering experience + writing ability + domain expertise.**

**Next step: Update resume/LinkedIn, apply to 5 roles this week.**

---

*Document created: December 27, 2025*
*Last updated: December 27, 2025*
